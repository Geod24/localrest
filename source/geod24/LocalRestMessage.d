/*******************************************************************************

    There are various data that nodes need to exchange messages.
    Send and receive data requests, responses, commands, etc.

*******************************************************************************/

module geod24.LocalRestMessage;

import geod24.concurrency;

import std.format;
import std.process;

import core.sync.mutex;
import core.atomic;
import core.thread;
import core.time;

public alias MessageChannel = Channel!Message;
public immutable size_t DefaultQueueSize = 1024;

/// Data sent by the caller
public struct Command
{
    /// In order to support re-entrancy, every request contains an id
    /// which should be copied in the `Response`
    /// Initialized to `size_t.max` so not setting it crashes the program
    size_t id = size_t.max;
    /// Method to call
    string method;
    /// Arguments to the method, JSON formatted
    string args;
}

/// Ask the node to exhibit a certain behavior for a given time
public struct TimeCommand
{
    /// For how long our remote node apply this behavior
    Duration dur;
    /// Whether or not affected messages should be dropped
    bool drop = false;
}

/// Ask the node to shut down
public struct ShutdownCommand
{
}

/// Filter out requests before they reach a node
public struct FilterAPI
{
    /// the mangled symbol name of the function to filter
    string func_mangleof;

    /// used for debugging
    string pretty_func;
}

/// When creating Message Pipeline
public struct CreatePipeCommand
{
    MessagePipeline pipeline;
}

/// When destructing Message Pipeline
public struct DestroyPipeCommand
{
}

/// Status of a request
public enum Status
{
    /// Request failed
    Failed,

    /// Request timed-out
    Timeout,

    /// Request succeeded
    Success
}

/// Data sent by the callee back to the caller
public struct Response
{
    /// Final status of a request (failed, timeout, success, etc)
    Status status;
    /// In order to support re-entrancy, every request contains an id
    /// which should be copied in the `Response` so the scheduler can
    /// properly dispatch this event
    /// Initialized to `size_t.max` so not setting it crashes the program
    size_t id;
    /// If `status == Status.Success`, the JSON-serialized return value.
    /// Otherwise, it contains `Exception.toString()`.
    string data;
}

// very simple & limited variant, to keep it performant.
// should be replaced by a real Variant later
public struct Message
{
    this (Command msg) { this.cmd = msg; this.tag = Message.Type.command; }
    this (Response msg) { this.res = msg; this.tag = Message.Type.response; }
    this (FilterAPI msg) { this.filter = msg; this.tag = Message.Type.filter; }
    this (TimeCommand msg) { this.time = msg; this.tag = Message.Type.time_command; }
    this (ShutdownCommand msg) { this.shutdown = msg; this.tag = Message.Type.shutdown_command; }
    this (CreatePipeCommand msg) { this.create_pipe = msg; this.tag = Message.Type.create_pipe_command; }
    this (DestroyPipeCommand msg) { this.destoy_pipe = msg; this.tag = Message.Type.destoy_pipe_command; }

    union
    {
        Command cmd;
        Response res;
        FilterAPI filter;
        TimeCommand time;
        ShutdownCommand shutdown;
        CreatePipeCommand create_pipe;
        DestroyPipeCommand destoy_pipe;
    }

    ubyte tag;

    /// Status of a request
    enum Type
    {
        command,
        response,
        filter,
        time_command,
        shutdown_command,
        create_pipe_command,
        destoy_pipe_command
    }
}


/*******************************************************************************

    The message pipeline has two channels.
    One is a server-side channel and the other is a client-side channel.
    The server-side channel receives requests, and the client-side channel
    receives responses.

*******************************************************************************/

public class MessagePipeline
{

    /// Channel of Requestor
    public MessageChannel producer;

    /// Channel of Responsor
    public MessageChannel consumer;

    /// Original Channel of Responsor
    private MessageChannel root_chan;

    /// Name, This is automatically generated by the ID of the thread.
    public string name;

    /// closed
    private bool closed;

    /// This value is true if another request is already in progress.
    private bool busy;

    /// lock for status
    private Mutex mutex;

    /// The next available request ID.
    private size_t last_request_id;


    /***********************************************************************

        Creator

        Params:
            root_chan = Original Channel of Responsor

    ***********************************************************************/

    public this (MessageChannel root_chan)
    {
        this (root_chan, new MessageChannel(DefaultQueueSize), new MessageChannel(DefaultQueueSize));
    }


    /***********************************************************************

        Creator

        Params:
            root_chan = Original Channel of Responsor
            producer = Channel of Requestor
            consumer = Channel of Responsor

    ***********************************************************************/

    public this (MessageChannel root_chan, MessageChannel producer, MessageChannel consumer)
    {
        this.mutex = new Mutex;
        this.producer = producer;
        this.consumer = consumer;

        this.closed = true;
        this.busy = false;
        this.root_chan = root_chan;

        this.last_request_id = 0;

        this.name = format("%x", thisThreadID);
    }


    /***********************************************************************

        Connect the pipeline.

    ***********************************************************************/

    public void open ()
    {
        if (!this.isClosed)
            return;

        this.root_chan.send(Message(CreatePipeCommand(this)));
        this.isClosed = false;
    }


    /***********************************************************************

        Disconnect the pipeline.

    ***********************************************************************/

    public void close ()
    {
        if (this.isClosed)
            return;

        this.consumer.send(Message(DestroyPipeCommand()));
        this.isClosed = true;
    }


    /***********************************************************************

        Request a response to the message through the pipeline.

        Params:
            req = request message
            timeout = any timeout to use

        Return:
            msg = value to receive

    ***********************************************************************/

    public Message query (Message req, Duration timeout = Duration.init)
    {
        if (this.isClosed)
            assert(0, "MessagePipeline is closed.");

        this.isBusy = true;
        scope (exit)
            this.isBusy = false;

        this.consumer.send(req);

        Message msg;
        auto limit = MonoTime.currTime + timeout;

        while (true)
        {
            if (this.producer.tryReceive(&msg))
            {
                if ((msg.tag == Message.Type.response) && (req.cmd.id == msg.res.id))
                    return msg;
            }

            if (timeout != Duration.init)
            {
                auto left = limit - MonoTime.currTime;
                if (left.isNegative)
                    return Message(Response(Status.Timeout, req.cmd.id));
            }

            thisScheduler.yield();
        }
    }


    /***********************************************************************

        Send a response message through the pipeline.

        Params:
            res = response message

    ***********************************************************************/

    public void reply (Message res)
    {
        if (this.isClosed)
            assert(0, "MessagePipeline is closed.");

        this.producer.send(res);
    }


    /***************************************************************************

        Return closing status.

        Returns:
            true if the message pipeline is closed, otherwise false.

    ***************************************************************************/

    public @property bool isClosed ()
    {
        this.mutex.lock();
        scope (exit)
            this.mutex.unlock();

        return this.closed;
    }


    /***************************************************************************

        Set closing status.

        Params:
            value = true if the message pipeline is closed

    ***************************************************************************/

    public @property void isClosed (bool value)
    {
        this.mutex.lock();
        scope (exit)
            this.mutex.unlock();

        this.closed = value;
    }


    /***************************************************************************

        Return busy status.

        Returns:
            true if the message pipeline is busy, otherwise false.

    ***************************************************************************/

    public @property bool isBusy ()
    {
        this.mutex.lock();
        scope (exit)
            this.mutex.unlock();

        return this.busy;
    }


    /***************************************************************************

        Set busy status.

        Params:
            value = true if the message pipeline is busy, otherwise false.

    ***************************************************************************/

    public @property void isBusy (bool value)
    {
        this.mutex.lock();
        scope (exit)
            this.mutex.unlock();

        this.busy = value;
    }


    /***************************************************************************

        Get the next available request ID.

        Returns:
            request ID.

    ***************************************************************************/

    public size_t getId ()
    {
        return this.last_request_id++;
    }
}


/*******************************************************************************

    This registry allows to look up a `MessagePipeline` based on a `ThreadID`.

*******************************************************************************/

public shared struct MessagePipelineRegistry
{
    static shared struct RegistryLock
    {
        void lock() { while (!cas(&locked, false, true)) { Thread.yield(); } }
        void unlock() { atomicStore!(MemoryOrder.rel)(locked, false); }
        bool locked;
    }
    static shared RegistryLock registry_lock;

    private MessagePipeline[string] pipelines;


    /***************************************************************************

        Gets the MessageChannel associated with name.

        Params:
            name = The name to locate within the registry.

        Return:
            The associated MessagePipeline or null
            if name is not registered.

    ***************************************************************************/

    public MessagePipeline locate (string name)
    {
        registry_lock.lock();
        scope (exit)
            registry_lock.unlock();

        if (shared(MessagePipeline)* p = name in this.pipelines)
            return *cast(MessagePipeline*)p;

        return null;
    }


    /***************************************************************************

        Gets the MessageChannel associated with name.

        Return:
            The associated MessagePipeline or null
            if name is not registered.

    ***************************************************************************/

    public MessagePipeline locate ()
    {
        auto name = format("%x", thisThreadID);

        return this.locate(name);
    }


    /***************************************************************************

        Register message pipeline.

        The message pipeline registers in its name.
        The name of the message pipeline is generated by the ID of the thread.
        Therefore, only one pipeline per thread is registered.

        Params:
            pipeline = Instanse of MessagePipeline.

        Return:
            If message pipeline is closed then return false. Others return true.

    ***************************************************************************/

    public bool register (MessagePipeline pipeline)
    {
        assert(pipeline !is null);

        registry_lock.lock();
        scope (exit)
            registry_lock.unlock();

        if (pipeline.isClosed)
            return false;

        this.pipelines[pipeline.name] = cast(shared)pipeline;
        return true;
    }


    /***************************************************************************

        Removes message pipeline

        Params:
            pipeline = Instanse of MessagePipeline

        Return:
            If message pipeline is already registered then return true,
            Others return false.

    ***************************************************************************/

    public bool unregister (MessagePipeline pipeline)
    {
        assert(pipeline !is null);

        registry_lock.lock();
        scope (exit)
            registry_lock.unlock();

        if (shared(MessagePipeline)* p = pipeline.name in this.pipelines)
        {
            this.pipelines.remove(pipeline.name);
            return true;
        }
        return false;
    }
}


/***************************************************************************

    Getter of MessageChannel assigned to a called thread.

    Returns:
        Returns instance of `MessageChannel` that is created by top thread.

***************************************************************************/

public @property MessageChannel thisMessageChannel () nothrow
{
    auto p = "messagechannel" in thisInfo.objects;
    if (p !is null)
        return cast(MessageChannel)*p;
    else
        return null;
}


/***************************************************************************

    Setter of MessageChannel assigned to a called thread.

    Params:
        value = The instance of `MessageChannel`.

***************************************************************************/

public @property void thisMessageChannel (MessageChannel value) nothrow
{
    thisInfo.objects["messagechannel"] = value;
}
